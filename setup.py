#!/usr/bin/env python3
"""
Homelab Inventory System - Setup Script

This script handles the setup and deployment of the homelab inventory system.
It manages environment variables, runs pre-deployment checks, and starts the
Docker containers.

Usage:
    python setup.py          # Interactive setup
    python setup.py --build  # Force rebuild containers
    python setup.py --down   # Stop and remove containers
"""

import os
import sys
import subprocess
import shutil
from pathlib import Path
from typing import Optional

# Configuration
ENV_FILE = ".env"
ENV_EXAMPLE_FILE = ".env.docker.example"

# Define required environment variables with their descriptions
# Add new variables here as the project grows
ENV_VARIABLES = [
    {
        "name": "TS_AUTHKEY",
        "description": "Tailscale authentication key",
        "required": False,  # Optional - only needed for Tailscale access
        "sensitive": True,  # Mask the displayed value
        "help": "Get from: https://login.tailscale.com/admin/settings/keys\n"
                "         Create a reusable, ephemeral key.\n"
                "         Leave empty to skip Tailscale integration."
    },
    {
        "name": "TS_HOSTNAME",
        "description": "Hostname on your Tailnet",
        "required": False,
        "sensitive": False,
        "default": "homelab-inventory",
        "help": "The hostname used to access this service on Tailscale.\n"
                "         Must be DNS-compatible (lowercase, no spaces).",
        "sanitize": "hostname"
    },
]


class Colors:
    """ANSI color codes for terminal output."""
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'


def print_header(text: str) -> None:
    """Print a formatted header."""
    print(f"\n{Colors.HEADER}{Colors.BOLD}{'=' * 60}{Colors.ENDC}")
    print(f"{Colors.HEADER}{Colors.BOLD}{text.center(60)}{Colors.ENDC}")
    print(f"{Colors.HEADER}{Colors.BOLD}{'=' * 60}{Colors.ENDC}\n")


def print_step(text: str) -> None:
    """Print a step indicator."""
    print(f"{Colors.CYAN}>> {text}{Colors.ENDC}")


def print_success(text: str) -> None:
    """Print a success message."""
    print(f"{Colors.GREEN}✓ {text}{Colors.ENDC}")


def print_warning(text: str) -> None:
    """Print a warning message."""
    print(f"{Colors.YELLOW}⚠ {text}{Colors.ENDC}")


def print_error(text: str) -> None:
    """Print an error message."""
    print(f"{Colors.RED}✗ {text}{Colors.ENDC}")


def mask_value(value: str, show_chars: int = 4) -> str:
    """Mask a sensitive value, showing only the last few characters."""
    if len(value) <= show_chars:
        return "*" * len(value)
    return "*" * (len(value) - show_chars) + value[-show_chars:]


def sanitize_hostname(hostname: str) -> str:
    """Sanitize a hostname to be DNS-compatible.

    - Lowercase
    - Replace spaces and special chars with hyphens
    - Remove consecutive hyphens
    - Remove leading/trailing hyphens
    """
    import re
    # Lowercase and replace non-alphanumeric (except hyphen) with hyphen
    sanitized = re.sub(r'[^a-z0-9-]', '-', hostname.lower())
    # Remove consecutive hyphens
    sanitized = re.sub(r'-+', '-', sanitized)
    # Remove leading/trailing hyphens
    sanitized = sanitized.strip('-')
    return sanitized or 'homelab-inventory'


def read_env_file() -> dict:
    """Read existing .env file and return as dictionary."""
    env_vars = {}
    env_path = Path(ENV_FILE)

    if env_path.exists():
        with open(env_path, 'r') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#') and '=' in line:
                    key, _, value = line.partition('=')
                    env_vars[key.strip()] = value.strip()

    return env_vars


def write_env_file(env_vars: dict) -> None:
    """Write environment variables to .env file."""
    with open(ENV_FILE, 'w') as f:
        f.write("# Homelab Inventory System - Environment Configuration\n")
        f.write("# Generated by setup.py\n\n")

        for var_config in ENV_VARIABLES:
            name = var_config["name"]
            if name in env_vars:
                f.write(f"# {var_config['description']}\n")
                f.write(f"{name}={env_vars[name]}\n\n")


def prompt_for_value(var_config: dict, current_value: Optional[str]) -> str:
    """Prompt user for an environment variable value."""
    name = var_config["name"]
    description = var_config["description"]
    sensitive = var_config.get("sensitive", False)
    required = var_config.get("required", False)
    default = var_config.get("default", "")
    help_text = var_config.get("help", "")

    print(f"\n{Colors.BOLD}{name}{Colors.ENDC} - {description}")

    if help_text:
        for line in help_text.split('\n'):
            print(f"  {Colors.CYAN}{line}{Colors.ENDC}")

    # Show current value
    if current_value:
        display_value = mask_value(current_value) if sensitive else current_value
        print(f"  Current value: {Colors.GREEN}{display_value}{Colors.ENDC}")
    else:
        print(f"  Current value: {Colors.YELLOW}(empty){Colors.ENDC}")
        if default:
            print(f"  Default: {Colors.CYAN}{default}{Colors.ENDC}")

    # Prompt for action
    if current_value:
        response = input(f"  Keep current value? [Y/n]: ").strip().lower()
        if response in ('', 'y', 'yes'):
            return current_value

    # Get new value
    prompt = f"  Enter new value"
    if not required:
        prompt += " (or press Enter to skip)"
    prompt += ": "

    new_value = input(prompt).strip()

    if not new_value:
        if required:
            print_warning("This field is required.")
            return prompt_for_value(var_config, current_value)
        return default if not current_value else current_value

    # Apply sanitization if configured
    sanitize_type = var_config.get("sanitize")
    if sanitize_type == "hostname" and new_value:
        sanitized = sanitize_hostname(new_value)
        if sanitized != new_value:
            print(f"  {Colors.YELLOW}Note: Sanitized to '{sanitized}'{Colors.ENDC}")
            new_value = sanitized

    return new_value


def check_docker() -> bool:
    """Check if Docker and Docker Compose are available."""
    print_step("Checking Docker installation...")

    # Check Docker
    try:
        result = subprocess.run(
            ["docker", "--version"],
            capture_output=True,
            text=True,
            check=True
        )
        print_success(f"Docker found: {result.stdout.strip()}")
    except (subprocess.CalledProcessError, FileNotFoundError):
        print_error("Docker is not installed or not in PATH")
        return False

    # Check Docker Compose
    try:
        result = subprocess.run(
            ["docker", "compose", "version"],
            capture_output=True,
            text=True,
            check=True
        )
        print_success(f"Docker Compose found: {result.stdout.strip()}")
    except subprocess.CalledProcessError:
        print_error("Docker Compose is not available")
        return False

    # Check Docker daemon
    try:
        subprocess.run(
            ["docker", "info"],
            capture_output=True,
            check=True
        )
        print_success("Docker daemon is running")
    except subprocess.CalledProcessError:
        print_error("Docker daemon is not running. Please start Docker.")
        return False

    return True


def run_docker_compose(command: list, description: str) -> bool:
    """Run a docker compose command."""
    print_step(description)

    full_command = ["docker", "compose"] + command
    print(f"  Running: {' '.join(full_command)}")

    try:
        subprocess.run(full_command, check=True)
        print_success(f"{description} completed successfully")
        return True
    except subprocess.CalledProcessError as e:
        print_error(f"{description} failed with exit code {e.returncode}")
        return False


def setup_environment() -> dict:
    """Interactive setup for environment variables."""
    print_header("Environment Configuration")

    # Read existing values
    current_env = read_env_file()
    new_env = {}

    print("Configure your environment variables:")
    print("(Press Ctrl+C to cancel at any time)")

    try:
        for var_config in ENV_VARIABLES:
            name = var_config["name"]
            current_value = current_env.get(name)
            new_env[name] = prompt_for_value(var_config, current_value)
    except KeyboardInterrupt:
        print("\n")
        print_warning("Setup cancelled by user")
        sys.exit(1)

    # Write the new configuration
    write_env_file(new_env)
    print_success(f"Configuration saved to {ENV_FILE}")

    return new_env


def show_status() -> None:
    """Show current status of the deployment."""
    print_header("Current Status")

    # Check if containers are running
    try:
        result = subprocess.run(
            ["docker", "compose", "ps", "--format", "table {{.Name}}\t{{.Status}}\t{{.Ports}}"],
            capture_output=True,
            text=True
        )
        if result.stdout.strip():
            print("Running containers:")
            print(result.stdout)
        else:
            print_warning("No containers are currently running")
    except subprocess.CalledProcessError:
        print_warning("Could not get container status")


def main():
    """Main entry point."""
    # Parse command line arguments
    args = sys.argv[1:]

    print_header("Homelab Inventory System Setup")

    # Change to script directory
    script_dir = Path(__file__).parent.resolve()
    os.chdir(script_dir)
    print(f"Working directory: {script_dir}")

    # Handle special commands
    if "--down" in args:
        if check_docker():
            run_docker_compose(["down"], "Stopping containers")
        return

    if "--status" in args:
        if check_docker():
            show_status()
        return

    # Check Docker availability
    if not check_docker():
        print_error("Please install Docker and Docker Compose to continue.")
        sys.exit(1)

    # Setup environment
    env_vars = setup_environment()

    # Pre-deployment checks (add more here as needed)
    print_header("Pre-deployment Checks")

    # Check if data directory exists
    data_dir = Path("data")
    if not data_dir.exists():
        print_step("Creating data directory...")
        data_dir.mkdir(exist_ok=True)
        print_success("Data directory created")
    else:
        print_success("Data directory exists")

    # Deployment
    print_header("Deployment")

    # Build and start containers
    build_flag = "--build" in args

    if build_flag:
        if not run_docker_compose(["build"], "Building containers"):
            sys.exit(1)

    if not run_docker_compose(["up", "-d"], "Starting containers"):
        sys.exit(1)

    # Show final status
    print_header("Deployment Complete!")

    show_status()

    # Show access information
    print("\n" + Colors.BOLD + "Access your inventory:" + Colors.ENDC)
    print(f"  Local:     http://localhost:3000")

    ts_hostname = env_vars.get("TS_HOSTNAME", "homelab-inventory")
    ts_authkey = env_vars.get("TS_AUTHKEY", "")

    if ts_authkey:
        print(f"  Tailscale: https://{ts_hostname}.<your-tailnet>.ts.net")
    else:
        print_warning("Tailscale not configured - only local access available")

    print(f"\n{Colors.CYAN}Useful commands:{Colors.ENDC}")
    print("  python setup.py --status  # Check container status")
    print("  python setup.py --down    # Stop containers")
    print("  python setup.py --build   # Rebuild and restart")
    print("  docker compose logs -f    # View logs")


if __name__ == "__main__":
    main()
