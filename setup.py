#!/usr/bin/env python3
"""
Homelab Inventory System - Setup Script

This script handles the setup and deployment of the homelab inventory system.
It manages environment variables, runs pre-deployment checks, and starts the
Docker containers.

Usage:
    python setup.py              # Interactive setup (asks what to do)
    python setup.py --rebuild    # Full rebuild: down, build --no-cache, up
    python setup.py --status     # Check container status
    python setup.py --down       # Stop and remove containers
    python setup.py --logs       # Follow container logs
"""

import os
import sys
import subprocess
from pathlib import Path
from typing import Optional

# Configuration
ENV_FILE = ".env"
ENV_EXAMPLE_FILE = ".env.docker.example"

# Define required environment variables with their descriptions
# Add new variables here as the project grows
ENV_VARIABLES = [
    {
        "name": "TS_AUTHKEY",
        "description": "Tailscale authentication key",
        "required": False,  # Optional - only needed for Tailscale access
        "sensitive": True,  # Mask the displayed value
        "help": "Get from: https://login.tailscale.com/admin/settings/keys\n"
                "         Create a reusable, ephemeral key.\n"
                "         Leave empty to skip Tailscale integration."
    },
    {
        "name": "TS_HOSTNAME",
        "description": "Hostname on your Tailnet",
        "required": False,
        "sensitive": False,
        "default": "homelab-inventory",
        "help": "The hostname used to access this service on Tailscale.\n"
                "         Must be DNS-compatible (lowercase, no spaces).",
        "sanitize": "hostname"
    },
]


class Colors:
    """ANSI color codes for terminal output."""
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'


def print_header(text: str) -> None:
    """Print a formatted header."""
    print(f"\n{Colors.HEADER}{Colors.BOLD}{'=' * 60}{Colors.ENDC}")
    print(f"{Colors.HEADER}{Colors.BOLD}{text.center(60)}{Colors.ENDC}")
    print(f"{Colors.HEADER}{Colors.BOLD}{'=' * 60}{Colors.ENDC}\n")


def print_step(text: str) -> None:
    """Print a step indicator."""
    print(f"{Colors.CYAN}>> {text}{Colors.ENDC}")


def print_success(text: str) -> None:
    """Print a success message."""
    print(f"{Colors.GREEN}✓ {text}{Colors.ENDC}")


def print_warning(text: str) -> None:
    """Print a warning message."""
    print(f"{Colors.YELLOW}⚠ {text}{Colors.ENDC}")


def print_error(text: str) -> None:
    """Print an error message."""
    print(f"{Colors.RED}✗ {text}{Colors.ENDC}")


def mask_value(value: str, show_chars: int = 4) -> str:
    """Mask a sensitive value, showing only the last few characters."""
    if len(value) <= show_chars:
        return "*" * len(value)
    return "*" * (len(value) - show_chars) + value[-show_chars:]


def sanitize_hostname(hostname: str) -> str:
    """Sanitize a hostname to be DNS-compatible."""
    import re
    sanitized = re.sub(r'[^a-z0-9-]', '-', hostname.lower())
    sanitized = re.sub(r'-+', '-', sanitized)
    sanitized = sanitized.strip('-')
    return sanitized or 'homelab-inventory'


def read_env_file() -> dict:
    """Read existing .env file and return as dictionary."""
    env_vars = {}
    env_path = Path(ENV_FILE)

    if env_path.exists():
        with open(env_path, 'r') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#') and '=' in line:
                    key, _, value = line.partition('=')
                    env_vars[key.strip()] = value.strip()

    return env_vars


def write_env_file(env_vars: dict) -> None:
    """Write environment variables to .env file."""
    with open(ENV_FILE, 'w') as f:
        f.write("# Homelab Inventory System - Environment Configuration\n")
        f.write("# Generated by setup.py\n\n")

        for var_config in ENV_VARIABLES:
            name = var_config["name"]
            if name in env_vars:
                f.write(f"# {var_config['description']}\n")
                f.write(f"{name}={env_vars[name]}\n\n")


def prompt_for_value(var_config: dict, current_value: Optional[str]) -> str:
    """Prompt user for an environment variable value."""
    name = var_config["name"]
    description = var_config["description"]
    sensitive = var_config.get("sensitive", False)
    required = var_config.get("required", False)
    default = var_config.get("default", "")
    help_text = var_config.get("help", "")

    print(f"\n{Colors.BOLD}{name}{Colors.ENDC} - {description}")

    if help_text:
        for line in help_text.split('\n'):
            print(f"  {Colors.CYAN}{line}{Colors.ENDC}")

    if current_value:
        display_value = mask_value(current_value) if sensitive else current_value
        print(f"  Current value: {Colors.GREEN}{display_value}{Colors.ENDC}")
    else:
        print(f"  Current value: {Colors.YELLOW}(empty){Colors.ENDC}")
        if default:
            print(f"  Default: {Colors.CYAN}{default}{Colors.ENDC}")

    if current_value:
        response = input(f"  Keep current value? [Y/n]: ").strip().lower()
        if response in ('', 'y', 'yes'):
            return current_value

    prompt = f"  Enter new value"
    if not required:
        prompt += " (or press Enter to skip)"
    prompt += ": "

    new_value = input(prompt).strip()

    if not new_value:
        if required:
            print_warning("This field is required.")
            return prompt_for_value(var_config, current_value)
        return default if not current_value else current_value

    sanitize_type = var_config.get("sanitize")
    if sanitize_type == "hostname" and new_value:
        sanitized = sanitize_hostname(new_value)
        if sanitized != new_value:
            print(f"  {Colors.YELLOW}Note: Sanitized to '{sanitized}'{Colors.ENDC}")
            new_value = sanitized

    return new_value


def check_docker() -> bool:
    """Check if Docker and Docker Compose are available."""
    print_step("Checking Docker installation...")

    try:
        result = subprocess.run(
            ["docker", "--version"],
            capture_output=True,
            text=True,
            check=True
        )
        print_success(f"Docker found: {result.stdout.strip()}")
    except (subprocess.CalledProcessError, FileNotFoundError):
        print_error("Docker is not installed or not in PATH")
        return False

    try:
        result = subprocess.run(
            ["docker", "compose", "version"],
            capture_output=True,
            text=True,
            check=True
        )
        print_success(f"Docker Compose found: {result.stdout.strip()}")
    except subprocess.CalledProcessError:
        print_error("Docker Compose is not available")
        return False

    try:
        subprocess.run(
            ["docker", "info"],
            capture_output=True,
            check=True
        )
        print_success("Docker daemon is running")
    except subprocess.CalledProcessError:
        print_error("Docker daemon is not running. Please start Docker.")
        return False

    return True


def is_container_running() -> bool:
    """Check if the container is currently running."""
    try:
        result = subprocess.run(
            ["docker", "compose", "ps", "-q"],
            capture_output=True,
            text=True
        )
        return bool(result.stdout.strip())
    except subprocess.CalledProcessError:
        return False


def run_docker_compose(command: list, description: str, stream_output: bool = False) -> bool:
    """Run a docker compose command."""
    print_step(description)

    full_command = ["docker", "compose"] + command
    print(f"  Running: {' '.join(full_command)}")

    try:
        if stream_output:
            # Stream output in real-time (for logs, build, etc.)
            subprocess.run(full_command, check=True)
        else:
            subprocess.run(full_command, check=True)
        print_success(f"{description} completed successfully")
        return True
    except subprocess.CalledProcessError as e:
        print_error(f"{description} failed with exit code {e.returncode}")
        return False
    except KeyboardInterrupt:
        print_warning("\nOperation cancelled by user")
        return False


def setup_environment() -> dict:
    """Interactive setup for environment variables."""
    print_header("Environment Configuration")

    current_env = read_env_file()
    new_env = {}

    print("Configure your environment variables:")
    print("(Press Ctrl+C to cancel at any time)")

    try:
        for var_config in ENV_VARIABLES:
            name = var_config["name"]
            current_value = current_env.get(name)
            new_env[name] = prompt_for_value(var_config, current_value)
    except KeyboardInterrupt:
        print("\n")
        print_warning("Setup cancelled by user")
        sys.exit(1)

    write_env_file(new_env)
    print_success(f"Configuration saved to {ENV_FILE}")

    return new_env


def show_status() -> None:
    """Show current status of the deployment."""
    print_header("Current Status")

    try:
        result = subprocess.run(
            ["docker", "compose", "ps", "--format", "table {{.Name}}\t{{.Status}}\t{{.Ports}}"],
            capture_output=True,
            text=True
        )
        if result.stdout.strip():
            print("Running containers:")
            print(result.stdout)
        else:
            print_warning("No containers are currently running")
    except subprocess.CalledProcessError:
        print_warning("Could not get container status")


def prompt_action() -> str:
    """Prompt user for what action to take."""
    print("\nWhat would you like to do?")
    print(f"  {Colors.BOLD}1{Colors.ENDC}) Fresh deploy (first time setup)")
    print(f"  {Colors.BOLD}2{Colors.ENDC}) Rebuild after code changes (down, build --no-cache, up)")
    print(f"  {Colors.BOLD}3{Colors.ENDC}) Quick restart (down, up)")
    print(f"  {Colors.BOLD}4{Colors.ENDC}) View logs")
    print(f"  {Colors.BOLD}5{Colors.ENDC}) Stop containers")
    print(f"  {Colors.BOLD}6{Colors.ENDC}) Check status")
    print(f"  {Colors.BOLD}q{Colors.ENDC}) Quit")

    while True:
        choice = input(f"\nEnter choice [{Colors.CYAN}1-6, q{Colors.ENDC}]: ").strip().lower()
        if choice in ('1', '2', '3', '4', '5', '6', 'q', 'quit', 'exit'):
            return choice
        print_warning("Invalid choice. Please enter 1-6 or q.")


def do_fresh_deploy(env_vars: dict) -> None:
    """Perform a fresh deployment."""
    print_header("Deployment")

    # Build and start
    if not run_docker_compose(["up", "-d", "--build"], "Building and starting containers", stream_output=True):
        sys.exit(1)

    show_final_info(env_vars)


def do_rebuild(env_vars: dict) -> None:
    """Perform a full rebuild after code changes."""
    print_header("Full Rebuild")

    # Stop existing containers
    run_docker_compose(["down"], "Stopping existing containers")

    # Build with no cache
    if not run_docker_compose(["build", "--no-cache"], "Rebuilding containers (no cache)", stream_output=True):
        sys.exit(1)

    # Start containers
    if not run_docker_compose(["up", "-d"], "Starting containers"):
        sys.exit(1)

    show_final_info(env_vars)


def do_quick_restart(env_vars: dict) -> None:
    """Perform a quick restart without rebuilding."""
    print_header("Quick Restart")

    run_docker_compose(["down"], "Stopping containers")

    if not run_docker_compose(["up", "-d"], "Starting containers"):
        sys.exit(1)

    show_final_info(env_vars)


def do_view_logs() -> None:
    """View container logs."""
    print_header("Container Logs")
    print("Press Ctrl+C to stop viewing logs\n")

    try:
        subprocess.run(["docker", "compose", "logs", "-f", "--tail", "100"])
    except KeyboardInterrupt:
        print("\n")
        print_success("Stopped viewing logs")


def show_final_info(env_vars: dict) -> None:
    """Show final deployment information."""
    print_header("Deployment Complete!")

    show_status()

    print("\n" + Colors.BOLD + "Access your inventory:" + Colors.ENDC)
    print(f"  Local:     http://localhost:3000")

    ts_hostname = env_vars.get("TS_HOSTNAME", "homelab-inventory")
    ts_authkey = env_vars.get("TS_AUTHKEY", "")

    if ts_authkey:
        print(f"  Tailscale: https://{ts_hostname}.<your-tailnet>.ts.net")
    else:
        print_warning("Tailscale not configured - only local access available")

    print(f"\n{Colors.CYAN}Useful commands:{Colors.ENDC}")
    print("  python setup.py           # Interactive menu")
    print("  python setup.py --rebuild # Full rebuild after code changes")
    print("  python setup.py --logs    # View container logs")
    print("  python setup.py --status  # Check container status")
    print("  python setup.py --down    # Stop containers")


def main():
    """Main entry point."""
    args = sys.argv[1:]

    print_header("Homelab Inventory System Setup")

    # Change to script directory
    script_dir = Path(__file__).parent.resolve()
    os.chdir(script_dir)
    print(f"Working directory: {script_dir}")

    # Handle command line flags
    if "--help" in args or "-h" in args:
        print(__doc__)
        return

    if "--down" in args:
        if check_docker():
            run_docker_compose(["down"], "Stopping containers")
        return

    if "--status" in args:
        if check_docker():
            show_status()
        return

    if "--logs" in args:
        if check_docker():
            do_view_logs()
        return

    if "--rebuild" in args:
        if not check_docker():
            print_error("Please install Docker and Docker Compose to continue.")
            sys.exit(1)

        # Quick env setup (show current values, allow changes)
        env_vars = setup_environment()

        # Pre-deployment checks
        print_header("Pre-deployment Checks")
        data_dir = Path("data")
        if not data_dir.exists():
            print_step("Creating data directory...")
            data_dir.mkdir(exist_ok=True)
            print_success("Data directory created")
        else:
            print_success("Data directory exists")

        do_rebuild(env_vars)
        return

    # Interactive mode
    if not check_docker():
        print_error("Please install Docker and Docker Compose to continue.")
        sys.exit(1)

    # Check current state
    container_running = is_container_running()
    if container_running:
        print_success("Containers are currently running")
    else:
        print_warning("No containers currently running")

    try:
        while True:
            choice = prompt_action()

            if choice in ('q', 'quit', 'exit'):
                print("\nGoodbye!")
                break

            if choice == '1':  # Fresh deploy
                env_vars = setup_environment()

                print_header("Pre-deployment Checks")
                data_dir = Path("data")
                if not data_dir.exists():
                    print_step("Creating data directory...")
                    data_dir.mkdir(exist_ok=True)
                    print_success("Data directory created")
                else:
                    print_success("Data directory exists")

                do_fresh_deploy(env_vars)
                break

            elif choice == '2':  # Rebuild
                env_vars = setup_environment()

                print_header("Pre-deployment Checks")
                data_dir = Path("data")
                if not data_dir.exists():
                    data_dir.mkdir(exist_ok=True)
                    print_success("Data directory created")

                do_rebuild(env_vars)
                break

            elif choice == '3':  # Quick restart
                env_vars = read_env_file()
                do_quick_restart(env_vars)
                break

            elif choice == '4':  # View logs
                do_view_logs()
                # Don't break - return to menu

            elif choice == '5':  # Stop
                run_docker_compose(["down"], "Stopping containers")
                break

            elif choice == '6':  # Status
                show_status()
                # Don't break - return to menu

    except KeyboardInterrupt:
        print("\n\nGoodbye!")
        sys.exit(0)


if __name__ == "__main__":
    main()
